---
layout: post
title: "Why I Use Windows on Desktop Rather than Linux"
---

I love using Linux on servers. I run web servers, write code, and do experiments with interesting projects using Linux (specifically Debian and Ubuntu). This blog post explains why I don't use Linux on desktop.

I am sorry. I really love Linux and open-source software, but realistically it never worked very well for me. I think this is partially due to the small user base that Linux has and partially due to design choices like the lack of backward compatibility, and the lack of "bloatware".

I had experimented with using Linux on Desktop for a while. I tried various distros like Ubuntu, Fedora, and Manjaro. I even built an Arch with i3, Rofi, and Polybar (I use Arch btw). Most of the time, installing and getting apps to work takes a long time, especially if I am learning about it for the first time.

# Backward Compatibility is Bad on Linux

Many open-source projects value new features and optimization and the "right" way to write code more than maintaining backward compatibility, which often means maintaining a bad design. As I programmer, I too hate having hacky workaround and messy code lying in the code base. However, as a user, I don't care. I just want my app to work even if the program runs a little slower or takes a bit more RAM and storage space.

One example of broken backward compatibility is glibc dropping support for DT_HASH in favor of the better-implemented DT_GNU_HASH because the developers of glibc (rightly) think that everyone should be using DT_GNU_HASH. But this broke software like Easy Anti-Cheat which relied on DT_HASH. Granted, fixing many of the breaking changes is extremely trivial, such as renaming a variable, pointing a path somewhere else, or even just recompiling the code to use the new ABI. However, as a developer, it is only trivial if you know what the root cause is, such as the line of code is causing the problem. Finding the problem takes time because usually, the place where the software fails is not where the problem occurs. One needs to spend a lot of time narrowing down the issue. Adding insult to injury, the debugging process is made difficult because all the search results are outdated. Fixing issues is even more difficult as a user of a program because I don't have access to the source code or the experience to know exactly how to look for the bug.

There are workarounds to these breaking changes. One such project that tires to make programs break less often is Flatpak. Flatpak uses container technology essentially to allow apps to version lock their dependencies and manage multiple versions of the same runtime library on a system.

Contrary to Linux, Microsoft really prioritizes backward compatibility. One example of this is the Excel "bug" that thinks that 1900 was a leap year. This bug was introduced in Lotus 1-2-3 and Microsoft copied the behavior to ensure compatibility with Lotus 1-2-3. This "bug" was never fixed and is even included in the formal specification of Excel to ensure that spreadsheets that used to work continue to work even though the behavior is not correct. There are more examples of Microsoft trying to maintain backward compatibility at the cost of correctness and ease of use for new developers. win32 ABI is still maintained to this day with its numerous flaws and idiosyncrasies. Developer Arek Hiler even wrote a blog post titled "Win32 Is The Only Stable ABI on Linux". UTF-8 character encoding is still not the default and is marked as beta because some programs still use non-UTF-8 encoding for non-English characters such as a Chinese stock trading app called Zhao Shang Zheng Quan. A new version of Powershell uses a different folder for the profile path to avoid conflict and maintain backward compatibility with the old version.

Microsoft's obsession with backward compatibility even extends to UI elements. I used to laugh at Windows for still having two settings pages -- one called Settings introduced in Windows 10 and the other called Control Panel introduced in Windows 7. The two pages share a lot of the same functions but have different UI layouts. So the inconsistency makes the OS look very ugly. I used to wish for a complete overhaul and unification, but now I understand and appreciate the reasons for choosing to include both programs. I can still change my settings in the same way as I did 10 years ago. Every guide, even ones designed for Windows 7, still works. Even though I haven't tried, I suspect hacky scripts written that interact with the computer based on graphical UI elements and mouse clicks would more or less still work with minimum changes.

# Lack of Bloatware Makes Installing Software Difficult

Backward compatibility is similar to how the lack of "bloatware" contributes to a complicated user experience on many Linux distributions. Many packages on Linux ship with the bare minimum to give the user fine control of the features they want to include to reduce "bloat". For example, when I install xorg-server, which is a program that basically coordinates GUI applications and their windows to be displayed on the screen, on Arch, it doesn't come with xinit, which is a used to start xorg-server. The reason behind this is that xorg-server and xinit and independent programs. There are many other ways to start xorg-server that do not use xinit. I appreciate this modular approach, but I think most people would want xinit with xorg-server. It took me quite a while, especially as I was installing xorg for the first time, to realise xinit was missing. I was trying to figure out if I installed xorg-server wrong or if my PATH variable was messed up. When something doesn't work, it always takes time to narrow down the cause and fix it even if it is just one simple install. I would have rather spent the extra bandwidth and disk space to install packages I didn't need than having to waste a lot of time hunting down the exact missing package. Also, many distributions don't even come with fonts for other languages like Chinese. It takes a while to find out what the exact Chinese font package is called and how to install it, especially for the first time. The lack of bloat makes the system use minimal RAM and storage. When there is nothing running, my Windows installation on my desktop takes a whopping 10GB whereas my Linux installation only uses a modest 2GB. But I think this is a price worth paying to have a simplified user experience.
